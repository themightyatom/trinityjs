<script type="module">
    import * as THREE from '/three/build/three.module.js';
    // import { RoomEnvironment } from '/three/examples/jsm/environments/RoomEnvironment.js';
    import { RGBELoader } from '/three/examples/jsm/loaders/RGBELoader.js';
    import { OrbitControls } from '/three/examples/jsm/controls/OrbitControls.js';
    
    import DecorManager from '/js/DecorManager.js';


    let camera, scene, renderer, preview, controls, width3d, height3d;;
    let targetMat, decorLayer;
    

    init('container');
    render();

    function init(cont) {

        const container = document.getElementById(cont);

        width3d = container.offsetWidth;
        height3d = container.offsetHeight;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width3d, height3d);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(45, width3d / height3d, 0.1, 30);
        camera.position.set(0, 1, 5);

        // const environment = new RoomEnvironment();
        // const pmremGenerator = new THREE.PMREMGenerator(renderer);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf8f8f8);

        scene.add(camera);

        decorLayer = new THREE.Object3D();
        scene.add(decorLayer);
        //scene.environment = pmremGenerator.fromScene(environment).texture;

        /* const grid = new THREE.GridHelper(20, 20, 0xffffff, 0xffffff);
         grid.material.opacity = 0.5;
         grid.material.depthWrite = false;
         grid.material.transparent = true;
         scene.add(grid);*/
        new RGBELoader()
            .setDataType(THREE.UnsignedByteType)
            .setPath('/env/')
            .load('mat2k.hdr', function (texture) {

                const envMap = pmremGenerator.fromEquirectangular(texture).texture;

                //scene.background = envMap;
                scene.environment = envMap;

                texture.dispose();
                pmremGenerator.dispose();
            });

        preview = new THREE.Object3D();
        scene.add(preview);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();

        controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', render); // use if there is no animation loop
        controls.minDistance = .1;
        controls.maxDistance = 10;
        controls.target.set(0, 1, 0);
        controls.update();

        window.addEventListener('resize', onWindowResize, false);

        DecorManager.setCamera(camera);
        DecorManager.setTargetLayer(decorLayer);
        DecorManager.setTargetWindow(container);
        DecorManager.setControls(controls);

        onWindowResize();

    }

    function onWindowResize() {
        width3d = container.offsetWidth;
        height3d = container.offsetHeight;
        DecorManager.setWindowSize(width3d, height3d);
        camera.aspect = width3d / height3d;
        camera.updateProjectionMatrix();
        renderer.setSize(width3d, height3d);
        render();

    }
 
    function hideAllSnaps() {
        for (var i = 0; i < snapPoints.length; i++) {
            snapPoints[i].visible = false;
        }
    }

    
    /*function adjustCamera(target) {
        let boundingBox = new THREE.Box3().setFromObject(target);
        let size = new THREE.Vector3();
        boundingBox.getSize(size) // Returns Vector3
        controls.target.set(target.position.x, size.y / 2, target.position.z);
        camera.position.y = size.y / 2;
        camera.position.x = target.position.x;
        camera.position.z = Math.max(size.x, size.y) * 2;
        camera.updateProjectionMatrix();
        render();
        camera.updateProjectionMatrix();
        render();
    }*/
    function render() {
        renderer.render(scene, camera);
    }
    function setCamPos(cam) {
        camera.position.copy(cam.position);
        camera.quaternion.copy(cam.quaternion);
        render();
    }
    function grabScreenshot() {
        renderer.render(scene, camera);
        return renderer.domElement.toDataURL();
    }
   
   

    function applyMaterialProperty(property, value) {

        switch (property) {
            case "diffuse_map":
                var loader = new THREE.TextureLoader();
                function onLoad(texture) {
                    targetMat.map = texture;
                    texture.flipY = false;
                    targetMat.needsUpdate = true;
                    targetMat.map.wrapS = THREE.RepeatWrapping;
                    targetMat.map.wrapT = THREE.RepeatWrapping;
                    render();
                }
                if (value == null) {
                    targetMat.map = null;
                    targetMat.needsUpdate = true;
                    render();
                } else {
                    loader.load("/textures/" + value, onLoad);
                }
                break;
            case "normal_map":
                var loader = new THREE.TextureLoader();
                function onnormLoad(texture) {
                    targetMat.normalMap = texture;
                    texture.flipY = false;
                    targetMat.normalMap.wrapS = THREE.RepeatWrapping;
                    targetMat.normalMap.wrapT = THREE.RepeatWrapping;
                    targetMat.needsUpdate = true;
                    render();
                }
                if (value == null) {
                    targetMat.normalMap = null;
                    targetMat.needsUpdate = true;
                    render();
                } else {
                    loader.load("/textures/" + value, onnormLoad);
                }

                break;
            case "normal_value":
                targetMat.normalScale = new THREE.Vector2(value, value);
                render();
                break;
            case "bump_map":
                var loader = new THREE.TextureLoader();
                function onbumpLoad(texture) {
                    targetMat.bumpMap = texture;
                    texture.flipY = false;
                    targetMat.bumpMap.wrapS = THREE.RepeatWrapping;
                    targetMat.bumpMap.wrapT = THREE.RepeatWrapping;
                    targetMat.needsUpdate = true;
                    render();
                }
                if (value == null) {
                    targetMat.bumpMap = null;
                    targetMat.needsUpdate = true;
                    render();
                } else {
                    loader.load("/textures/" + value, onbumpLoad);
                }
                break;
            case "bump_value":
                targetMat.bumpScale = value;
                render();
                break;
            case "color_hex":
                var hx = value.substr(1);
                targetMat.color.setHex('0x' + hx);
                render();
                break;
            case "emissive_hex":
                var hx = value.substr(1);
                targetMat.emissive.setHex('0x' + hx);
                render();
                break;
            case "opacity_value":
                targetMat.opacity = value;
                if (value == 1) {
                    targetMat.transparent = false;
                } else {
                    targetMat.transparent = true;
                }
                render();
                break;
            case "roughness_value":
                targetMat.roughness = value;
                render();
                break;
            case "metalness_value":
                targetMat.metalness = value;
                render();
                break;
            case "bump_map":
                var loader = new THREE.TextureLoader();
                function onmapLoad(texture) {
                    targetMat.bumpMap = texture;
                    texture.flipY = false;
                    targetMat.needsUpdate = true;
                    render();
                }
                loader.load("/textures/" + value, onmapLoad);
                break;
            case "bump_value":
                targetMat.bumpScale = value;
                render();
                break;

            default:
                break;
        }
    } 

    window.applyMaterialProperty = applyMaterialProperty;
    window.addAccessory = DecorManager.addAccessory;
    window.loadModel = DecorManager.addGroup;
    window.render = render;
    window.changeMaterial = DecorManager.changeMaterial;
    window.createAR = DecorManager.createAR;


</script>
<script type="module">
    import * as THREE from '/three/build/three.module.js';
    import { RoomEnvironment } from '/three/examples/jsm/environments/RoomEnvironment.js';
    import { OrbitControls } from '/three/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from '/three/examples/jsm/loaders/GLTFLoader.js';


    let camera, scene, renderer, preview, controls, width3d, height3d;;
    let targetMat;
    let targets = [];

    init('container');
    render();




    function init(cont) {

        const container = document.getElementById(cont);

        width3d = container.offsetWidth - 20;
        height3d = container.offsetHeight - 20;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width3d, height3d);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);



        camera = new THREE.PerspectiveCamera(45, width3d / height3d, 0.1, 30);
        camera.position.set(0, 1, 5);

        const environment = new RoomEnvironment();
        const pmremGenerator = new THREE.PMREMGenerator(renderer);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xCCCCCC);
        scene.environment = pmremGenerator.fromScene(environment).texture;

        const grid = new THREE.GridHelper(20, 20, 0xffffff, 0xffffff);
        grid.material.opacity = 0.5;
        grid.material.depthWrite = false;
        grid.material.transparent = true;
        scene.add(grid);

        preview = new THREE.Object3D();
        scene.add(preview);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', render); // use if there is no animation loop
        controls.minDistance = .1;
        controls.maxDistance = 10;
        controls.target.set(0, 1, 0);
        controls.update();

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize() {
        let win = document.getElementById("container");
        camera.aspect = width3d / height3d;
        camera.updateProjectionMatrix();

        renderer.setSize(width3d, height3d);

        render();

    }
    function loadModel(path, cb) {
        const loader = new GLTFLoader().setPath('/glb/');
        loader.load(path, (gltf) => {
            analyzeModel(gltf);
            if (cb) {
                cb();
            }
        })

    }
    function analyzeModel(gltf) {
        let snapPoints = [];
        targets = [];

        gltf.scene.traverse(function (child) {
            if (child.name.substr(0, 3) == "_as" && !child.isMesh) {
                snapPoints.push(child.name)
            } else {

            };
            if (child.isMesh) {
                switch (child.name.substr(0, 4)) {
                    case 'wood':
                        // child.material = SharedMaterials.getMaterialFromID('lightWood');
                        targetMat = child.material;
                        //  child.material.map.wrapS = THREE.RepeatWrapping;
                        //  child.material.map.wrapT = THREE.RepeatWrapping;
                        break;
                    case 'glas':
                        // child.material = SharedMaterials.getMaterialFromID('glass');
                        break;
                    case 'prev':
                        targetMat = child.material;
                        //  child.material.map.wrapS = THREE.RepeatWrapping;
                        //  child.material.map.wrapT = THREE.RepeatWrapping;
                        break;
                    default:
                        break;

                }


            }

        });
        //clear preview
        while (preview.children.length > 0) {
            preview.remove(preview.children[0]);
        }
        preview.add(gltf.scene);
        onWindowResize();
        render();
        //window.registerSnaps(snapPoints);
        if (window.registerTargets) {
            window.registerTargets(targets);
        }
        adjustCamera(gltf.scene);

    }

    function loadDataAsModel(data) {
        const loader = new GLTFLoader();

        loader.parse(data, '', function (gltf) {

            analyzeModel(gltf);
        });
    }
    function adjustCamera(target) {
        let boundingBox = new THREE.Box3().setFromObject(target);
        let size = new THREE.Vector3();
        boundingBox.getSize(size) // Returns Vector3
        controls.target.set(target.position.x, size.y / 2, target.position.z);
        camera.position.y = size.y / 2;
        camera.position.x = target.position.x;
        camera.position.z = Math.max(size.x, size.y) * 2;
        camera.updateProjectionMatrix();
        render();
        camera.updateProjectionMatrix();
        render();
    }




    function render() {

        renderer.render(scene, camera);

    }
    function setCamPos(cam) {
        camera.position.copy(cam.position);
        camera.quaternion.copy(cam.quaternion);
        render();
    }
    function grabScreenshot() {


        // open in new window like this
        //
       // var w = window.open('', '');
        //w.document.title = "Screenshot";
        //w.document.body.style.backgroundColor = "red";
       // var img = new Image();
        // Without 'preserveDrawingBuffer' set to true, we must render now
        renderer.render(scene, camera);
        //img.src = renderer.domElement.toDataURL();
        //w.document.body.appendChild(img);
        return renderer.domElement.toDataURL();
        /*
            // download file like this.
            //
            var a = document.createElement('a');
            // Without 'preserveDrawingBuffer' set to true, we must render now
            renderer.render(scene, camera);
            a.href = renderer.domElement.toDataURL().replace("image/png", "image/octet-stream");
            a.download = 'canvas.png'
            a.click();
        */

        /*
            // New version of file download using toBlob.
            // toBlob should be faster than toDataUrl.
            // But maybe not because also calling createOjectURL.
            //
            renderer.render(scene, camera);
            renderer.domElement.toBlob(function(blob){
                var a = document.createElement('a');
              var url = URL.createObjectURL(blob);
              a.href = url;
              a.download = 'canvas.png';
              a.click();
            }, 'image/png', 1.0);
        */

    }
    
    function applyMaterialProperty(property, value) {

        switch (property) {
            case "diffuse_map":
                var loader = new THREE.TextureLoader();
                function onLoad(texture) {
                    targetMat.map = texture;
                    texture.flipY = false;
                    targetMat.needsUpdate = true;
                    targetMat.map.wrapS = THREE.RepeatWrapping;
                    targetMat.map.wrapT = THREE.RepeatWrapping;
                    render();
                }
                 if(value == null){
                    targetMat.map = null;
                    targetMat.needsUpdate = true;
                    render();
                }else{
                       loader.load("/textures/" + value, onLoad);
                }
                break;
            case "normal_map":
                var loader = new THREE.TextureLoader();
                function onnormLoad(texture) {
                    targetMat.normalMap = texture;
                    texture.flipY = false;
                    targetMat.normalMap.wrapS = THREE.RepeatWrapping;
                    targetMat.normalMap.wrapT = THREE.RepeatWrapping;
                    targetMat.needsUpdate = true;
                    render();
                }
                 if(value == null){
                    targetMat.normalMap = null;
                    targetMat.needsUpdate = true;
                    render();
                }else{
                    loader.load("/textures/" + value, onnormLoad);
                }
                
                break;
             case "normal_value":
                targetMat.normalScale = new THREE.Vector2(value, value);
                render();
                break;
            case "bump_map":
                var loader = new THREE.TextureLoader();
                function onbumpLoad(texture) {
                    targetMat.bumpMap = texture;
                    texture.flipY = false;
                    targetMat.bumpMap.wrapS = THREE.RepeatWrapping;
                    targetMat.bumpMap.wrapT = THREE.RepeatWrapping;
                    targetMat.needsUpdate = true;
                    render();
                }
                if(value == null){
                    targetMat.bumpMap = null;
                    targetMat.needsUpdate = true;
                    render();
                }else{
                    loader.load("/textures/" + value, onbumpLoad);
                }
                break;
            case "bump_value":
                targetMat.bumpScale = value;
                render();
                break;
            case "color_hex":
                var hx = value.substr(1);
                targetMat.color.setHex('0x' + hx);
                render();
                break;
            case "emissive_hex":
                var hx = value.substr(1);
                targetMat.emissive.setHex('0x' + hx);
                render();
                break;
            case "opacity_value":
                targetMat.opacity = value;
                if (value == 1) {
                    targetMat.transparent = false;
                } else {
                    targetMat.transparent = true;
                }
                render();
                break;
            case "roughness_value":
                targetMat.roughness = value;
                render();
                break;
            case "metalness_value":
                targetMat.metalness = value;
                render();
                break;
            case "bump_map":
                var loader = new THREE.TextureLoader();
                function onmapLoad(texture) {
                    targetMat.bumpMap = texture;
                    texture.flipY = false;
                    targetMat.needsUpdate = true;
                    render();
                }
                loader.load("/textures/" + value, onmapLoad);
                break;
            case "bump_value":
                targetMat.bumpScale = value;
                render();
                break;

            default:
                break;
        }
    }

    window.loadDataAsModel = loadDataAsModel;
    window.loadModel = loadModel;
    window.setCamPos = setCamPos;
    window.render = render;
    window.applyMaterialProperty = applyMaterialProperty;
    window.grabScreenshot = grabScreenshot;


</script>